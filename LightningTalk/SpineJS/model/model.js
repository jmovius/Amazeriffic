(function (Spine, $, exports){
    "use strict";

    /* ----- Model ----- */
    var Comment = Spine.Model.sub(); // Init new Spine model object by extending Spine.Model.
    Comment.configure("Comment", "comment", "isHidden"); // Object name and private members
    Comment.extend(Spine.Model.Local); // Set Comment to store to local data.

    // Instance Methods
    Comment.extend({
        // Initializes an array of comments
        //  Input: HTML tag used to wrap the comment.
        // Output: An array of JQuery objects the controller can use to update the view.
        //         e.g. ["<[tag] id=[this.id] class="visible [_hiddenClass]">[this.comment]</[tag]>", ...]
        initCommentsWithTag: function (tag, hiddenClass) {
            var cmts = Comment.all(); // Get all comments.

            // Refactor the array of comment objects using map to retrieve the value of 
            cmts = cmts.map(function (cmt) {
                return(cmt.getJqueryWithTag(this.tag, this.hiddenClass));
            }, {tag:tag, hiddenClass:hiddenClass});

            return(cmts);
        },
        getNewComment: function (msg) {
            var cmt = new Comment({comment:msg, isHidden:false});

            // Potential Bug with SpineJS:
            //       To recreate, comment line 56, then load the page with
            //       zero records (delete all comments and refresh). Create 8 records, so
            //       the latest item saved has the id "c-8". Next click the "Delete All
            //       Comments" button. Create a few more comments, so the latest comment
            //       is "c-15" (these comments will start at "c-9" because this is where
            //       the model left off). Lastly, refresh the page again. Now, when creating
            //       comments, the newest comment will start at "c-7", then "c-8", then "c-16".
            //       Everything will behave as normal; however, hit refresh and the top 7
            //       7 records will be offset -- if you click any of the top 7 records, they will
            //       hide the record 7 places lower. I have verified the ID's received by my
            //       hiddenController are correct; however, when I call the built-in instance
            //       method "Comment.find([id])", the incorrect object with a different ID is
            //       returned. To correct this, I'm using an undocumented Class Method that
            //       resets all IDs starting at zero; therefore, the error will not appear.
            //
            // tl;dr: There's a bug with how SpineJS allocates Model object IDs after
            //        records have been destroyed; this bug may be related to how the
            //        Spine.Model.Local storage works.
            //
            // Since the bug is based on how the ID is allocated, I have forced the ID to
            // be equal to the length of the number of comments. It's important to note
            // this solution will not work with the option to delete individual comments.
            //
            // In light of this issue, it may be best for the user to keep track of IDs
            // separately and utilize this undocumented Class Method (apparently the dev
            // has fallen behind on documentation) to ensure the IDs do not overlap on
            // the back-end.
            cmt.changeID("c-" + Comment.all().length);

            cmt.save();
            return(cmt);
        }
    });

    // Class Methods
    Comment.include({
        // Formats the HTML to display the comment.
        // HTML id is set to the id automatically generated by the Spine data model.
        getJqueryWithTag: function (tag, hiddenClass) {
            var hidden;

            // If a comment was created, but not saved, then save it.
            // NOTE: This will only fire if the controller creates a new comment manually
            //       and does not save it (does not use Comment.newComment(msg) to create a comment).
            if(this.isNew()) {
                this.save();
            }

            if(this.isHidden) {
                hidden = " " + hiddenClass;
            } else {
                hidden = "";
            }

            return($("<" + tag + ">").attr("id", this.id).attr("class", tag + "Cmt" + hidden).html(this.comment));
        },
        // Toggles the isHidden value to true or false depending on its current value.
        toggleHiddenClass: function () {
            this.isHidden = (!this.isHidden);
            this.save();
            return(this.isHidden);
        }
    });

    // Example of binding an event handler to the model.
    Comment.bind("create", function (cmt) {
        console.log("New Comment: " + cmt.comment);
    });
    
    // Pull local data and load it to Comment.
    Comment.fetch();

    // ensure the Comment model is in the global namespace.
	exports.Comment = Comment;

})(Spine, Spine.$, window);
